<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Driver Search ‚Äî Dispatch Distance Coeff</title>
<script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
<script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #0f1117; }
  input[type=range] { width: 100%; }
</style>
</head>
<body>
<div id="root"></div>
<script type="text/babel">
const { useState, useEffect, useRef } = React;

const W = 580, H = 540;
const CX = W / 2, CY = H / 2;
const R = 72;

function hexToPixel(q, r) {
  return {
    x: CX + R * (3/2 * q),
    y: CY + R * (Math.sqrt(3)/2 * q + Math.sqrt(3) * r)
  };
}

function hexCorners(cx, cy, r) {
  return Array.from({ length: 6 }, (_, i) => {
    const a = (Math.PI / 3) * i;
    return `${cx + r * Math.cos(a)},${cy + r * Math.sin(a)}`;
  }).join(" ");
}

const hexGrid = [
  { q: 0, r: 0, ring: 0 },
  { q: 1, r: 0, ring: 1 }, { q: 1, r: -1, ring: 1 },
  { q: 0, r: -1, ring: 1 }, { q: -1, r: 0, ring: 1 },
  { q: -1, r: 1, ring: 1 }, { q: 0, r: 1, ring: 1 },
  { q: 2, r: 0, ring: 2 }, { q: 2, r: -1, ring: 2 }, { q: 2, r: -2, ring: 2 },
  { q: 1, r: -2, ring: 2 }, { q: 0, r: -2, ring: 2 }, { q: -1, r: -1, ring: 2 },
  { q: -2, r: 0, ring: 2 }, { q: -2, r: 1, ring: 2 }, { q: -2, r: 2, ring: 2 },
  { q: -1, r: 2, ring: 2 }, { q: 0, r: 2, ring: 2 }, { q: 1, r: 1, ring: 2 },
].map((h, i) => ({ ...h, id: i, center: hexToPixel(h.q, h.r) }));

const DRIVERS_BASE = [
  { id: 0, label: "A", angle: 30,  baseDist: 38  },
  { id: 1, label: "B", angle: 130, baseDist: 105 },
  { id: 2, label: "C", angle: 320, baseDist: 95  },
  { id: 3, label: "D", angle: 220, baseDist: 190 },
  { id: 4, label: "E", angle: 60,  baseDist: 210 },
];

const DRIVER_COLORS = ["#4A90D9","#50C878","#F5A623","#FF6B9D","#A78BFA"];

function getPos(d, coeff) {
  const rad = (d.angle * Math.PI) / 180;
  const dist = d.baseDist * coeff;
  return { x: CX + Math.cos(rad) * dist, y: CY + Math.sin(rad) * dist, dist };
}

function computeOrder(coeffs) {
  return DRIVERS_BASE
    .map(d => ({ ...d, dist: d.baseDist * coeffs[d.id] }))
    .sort((a, b) => a.dist - b.dist)
    .map((d, i) => ({ id: d.id, dispatchOrder: i + 1 }));
}

function btnStyle(color, disabled) {
  return {
    background: disabled ? "#1a1d2e" : color + "22",
    border: `1.5px solid ${disabled ? "#2a2d3e" : color}`,
    color: disabled ? "#555" : "#fff",
    borderRadius: 8, padding: "8px 14px", fontSize: 13,
    cursor: disabled ? "default" : "pointer", fontWeight: 600,
    transition: "all 0.2s",
  };
}

function App() {
  const [stage, setStage] = useState(0);
  const [autoPlay, setAutoPlay] = useState(false);
  const [coeffs, setCoeffs] = useState({ 0:1, 1:1, 2:1, 3:1, 4:1 });
  const [expanded, setExpanded] = useState(false);
  const timerRef = useRef(null);

  const orderMap = computeOrder(coeffs);
  const dispatchOrder = Object.fromEntries(orderMap.map(o => [o.id, o.dispatchOrder]));
  const sortedDrivers = [...DRIVERS_BASE].sort((a,b) => dispatchOrder[a.id] - dispatchOrder[b.id]);

  const MAX_STAGE = sortedDrivers.length * 2;
  const totalSteps = MAX_STAGE;

  function getStageInfo(s) {
    if (s === 0) return { label: "Order created", desc: "Passenger created a ride. System begins searching ‚Äî nearest driver first.", activeId: null, missedIds: [] };
    const stepDriver = Math.ceil(s / 2);
    const isSignal = s % 2 === 1;
    const driver = sortedDrivers[stepDriver - 1];
    const missed = sortedDrivers.slice(0, stepDriver - 1).map(d => d.id);
    if (stepDriver > sortedDrivers.length) {
      return { label: "All drivers tried ‚úì", desc: "5 drivers reached. Order moves to the Feed.", activeId: null, missedIds: sortedDrivers.map(d => d.id) };
    }
    const dist = Math.round(driver.baseDist * coeffs[driver.id]);
    if (isSignal) {
      return {
        label: `Signal ‚Üí Driver ${driver.label} (dispatch #${dispatchOrder[driver.id]})`,
        desc: `Nearest available driver at ${dist}px from point A. ‚è± 40 sec timer started.`,
        activeId: driver.id, missedIds: missed,
      };
    } else {
      const isLast = stepDriver === sortedDrivers.length;
      return {
        label: `Driver ${driver.label} ‚Äî ${isLast ? "confirmed ‚úÖ" : "no response"}`,
        desc: isLast
          ? `Driver ${driver.label} called the passenger. Both confirmed. Order assigned! üéâ`
          : `No reaction from driver ${driver.label}. Moving to the next nearest driver.`,
        activeId: isLast ? driver.id : null,
        confirmedId: isLast ? driver.id : null,
        missedIds: isLast ? missed : [...missed, driver.id],
      };
    }
  }

  useEffect(() => {
    if (autoPlay) {
      timerRef.current = setInterval(() => {
        setStage(s => { if (s >= totalSteps) { setAutoPlay(false); return s; } return s+1; });
      }, 1800);
    }
    return () => clearInterval(timerRef.current);
  }, [autoPlay, totalSteps]);

  const prevOrder = useRef(JSON.stringify(dispatchOrder));
  useEffect(() => {
    const next = JSON.stringify(dispatchOrder);
    if (prevOrder.current !== next) {
      setStage(0);
      setAutoPlay(false);
      prevOrder.current = next;
    }
  }, [dispatchOrder]);

  const stageInfo = getStageInfo(stage);
  const activeId = stageInfo.activeId;
  const confirmedId = stageInfo.confirmedId;
  const missedIds = stageInfo.missedIds || [];
  const isSuccess = !!confirmedId;

  function driverState(d) {
    if (confirmedId === d.id) return "matched";
    if (activeId === d.id) return "ringing";
    if (missedIds.includes(d.id)) return "missed";
    return "idle";
  }

  const driverStateColors = { idle: "#3a3d55", ringing: "#F5A623", missed: "#E74C3C", matched: "#27AE60" };
  const driverStateIcons  = { idle: "üöó", ringing: "üì≥", missed: "‚úó", matched: "‚úÖ" };

  function setCoeff(id, val) {
    setCoeffs(c => ({ ...c, [id]: val }));
  }

  return (
    <div style={{ background: "#0f1117", minHeight: "100vh", display: "flex", flexDirection: "column", alignItems: "center", padding: "20px 12px", fontFamily: "'Segoe UI', sans-serif", color: "#fff" }}>
      <h2 style={{ margin: "0 0 2px", fontSize: 17 }}>Driver Search ‚Äî Dispatch</h2>
      <p style={{ color: "#888", fontSize: 12, margin: "0 0 10px" }}>Intercity ¬∑ order always goes to the nearest driver first</p>

      <div style={{ width: "100%", maxWidth: W, background: "#1a1d2e", border: "1.5px solid #2a2d3e", borderRadius: 12, padding: "12px 16px", marginBottom: 10 }}>
        <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center" }}>
          <div style={{ fontSize: 13, fontWeight: 700 }}>
            üìê Distance coefficients
            <span style={{ fontSize: 11, fontWeight: 400, color: "#666", marginLeft: 8 }}>changing order in real-time</span>
          </div>
          <div style={{ display: "flex", gap: 8 }}>
            <button onClick={() => setCoeffs({0:1,1:1,2:1,3:1,4:1})} style={{ ...btnStyle("#555"), padding: "4px 10px", fontSize: 11 }}>Reset all</button>
            <button onClick={() => setExpanded(e => !e)} style={{ ...btnStyle("#7B68EE"), padding: "4px 10px", fontSize: 11 }}>{expanded ? "‚ñ≤ Hide" : "‚ñº Edit"}</button>
          </div>
        </div>

        <div style={{ display: "flex", gap: 6, marginTop: 10, flexWrap: "wrap" }}>
          {sortedDrivers.map((d, i) => {
            const col = DRIVER_COLORS[d.id];
            const dist = Math.round(d.baseDist * coeffs[d.id]);
            return (
              <div key={d.id} style={{ display: "flex", alignItems: "center", gap: 5, background: "#12151f", borderRadius: 8, padding: "5px 10px", border: `1.5px solid ${col}55` }}>
                <div style={{ width: 16, height: 16, borderRadius: "50%", background: col, display: "flex", alignItems: "center", justifyContent: "center", fontSize: 9, fontWeight: 800, color: "#000" }}>{i+1}</div>
                <span style={{ fontSize: 12, fontWeight: 700, color: col }}>Driver {d.label}</span>
                <span style={{ fontSize: 10, color: "#555" }}>{coeffs[d.id].toFixed(1)}√ó ¬∑ {dist}px</span>
              </div>
            );
          })}
        </div>

        {expanded && (
          <div style={{ marginTop: 12 }}>
            {DRIVERS_BASE.map(d => {
              const col = DRIVER_COLORS[d.id];
              const c = coeffs[d.id];
              const order = dispatchOrder[d.id];
              const dist = Math.round(d.baseDist * c);
              return (
                <div key={d.id} style={{ marginBottom: 8, background: "#12151f", borderRadius: 10, padding: "10px 12px", border: `1.5px solid ${col}33` }}>
                  <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: 6 }}>
                    <div style={{ display: "flex", alignItems: "center", gap: 8 }}>
                      <div style={{ width: 28, height: 28, borderRadius: "50%", background: col+"22", border: `1.5px solid ${col}`, display: "flex", alignItems: "center", justifyContent: "center", fontSize: 13 }}>üöó</div>
                      <div>
                        <div style={{ fontSize: 12, fontWeight: 700 }}>Driver {d.label}</div>
                        <div style={{ fontSize: 10, color: "#555" }}>base: {d.baseDist}px</div>
                      </div>
                    </div>
                    <div style={{ textAlign: "right" }}>
                      <div style={{ fontSize: 15, fontWeight: 800, color: col }}>{c.toFixed(1)}√ó</div>
                      <div style={{ fontSize: 10, color: "#555" }}>‚Üí {dist}px ¬∑ dispatch #{order}</div>
                    </div>
                  </div>
                  <div style={{ display: "flex", alignItems: "center", gap: 8 }}>
                    <span style={{ fontSize: 10, color: "#444" }}>0</span>
                    <input type="range" min={0} max={2} step={0.05} value={c}
                      onChange={e => setCoeff(d.id, parseFloat(e.target.value))}
                      style={{ flex: 1, accentColor: col, cursor: "pointer" }}/>
                    <span style={{ fontSize: 10, color: "#444" }}>2</span>
                    <button onClick={() => setCoeff(d.id, 1)} style={{ ...btnStyle("#555"), padding: "2px 8px", fontSize: 10 }}>1√ó</button>
                  </div>
                  <div style={{ height: 3, background: "#1e2235", borderRadius: 2, marginTop: 6, overflow: "hidden" }}>
                    <div style={{ height: "100%", width: `${(c/2)*100}%`, background: col, borderRadius: 2, transition: "width 0.15s" }}/>
                  </div>
                </div>
              );
            })}
          </div>
        )}
      </div>

      <div style={{ width: "100%", maxWidth: W }}>
        <svg viewBox={`0 0 ${W} ${H}`} width="100%" style={{ display: "block" }}>
          <defs>
            <filter id="glow" x="-40%" y="-40%" width="180%" height="180%">
              <feGaussianBlur stdDeviation="6" result="blur"/>
              <feMerge><feMergeNode in="blur"/><feMergeNode in="SourceGraphic"/></feMerge>
            </filter>
            <filter id="softglow" x="-20%" y="-20%" width="140%" height="140%">
              <feGaussianBlur stdDeviation="3" result="blur"/>
              <feMerge><feMergeNode in="blur"/><feMergeNode in="SourceGraphic"/></feMerge>
            </filter>
            <radialGradient id="bg" cx="50%" cy="50%">
              <stop offset="0%" stopColor="#161b2e"/>
              <stop offset="100%" stopColor="#0f1117"/>
            </radialGradient>
          </defs>
          <rect width={W} height={H} fill="url(#bg)"/>

          {hexGrid.map(h => {
            let fill="#11141f", stroke="#1c2030", strokeW=1, filterAttr=undefined;
            if (h.ring===0) { fill="#0d1e36"; stroke="#4A90D9"; strokeW=2; filterAttr="url(#softglow)"; }
            else if (h.ring===1) { fill="#141728"; stroke="#2a2d4a"; }
            else { fill="#111420"; stroke="#1a1d30"; }
            return <polygon key={h.id} points={hexCorners(h.center.x, h.center.y, R-2)} fill={fill} stroke={stroke} strokeWidth={strokeW} filter={filterAttr}/>;
          })}

          {stage > 0 && [0,1,2].map(i => (
            <circle key={i} cx={CX} cy={CY} r={10} fill="none" stroke="#4A90D9" strokeWidth={1.5} opacity={0}
              style={{ animation: `ripple 2.4s ${i*0.7}s ease-out infinite` }}/>
          ))}

          {DRIVERS_BASE.map(d => {
            const pos = getPos(d, coeffs[d.id]);
            const ds = driverState(d);
            const col = DRIVER_COLORS[d.id];
            const lineCol = ds === "matched" ? "#27AE60" : ds === "ringing" ? "#F5A623" : ds === "missed" ? "#E74C3C" : col;
            const opacity = ds === "idle" ? 0.15 : ds === "missed" ? 0.2 : 0.65;
            const sw = ds === "ringing" || ds === "matched" ? 1.5 : 1;
            const dash = ds === "ringing" || ds === "matched" ? "5 4" : "2 5";
            return <line key={d.id} x1={CX} y1={CY} x2={pos.x} y2={pos.y}
              stroke={lineCol} strokeWidth={sw} strokeDasharray={dash} opacity={opacity}/>;
          })}

          {DRIVERS_BASE.map(d => {
            const pos = getPos(d, coeffs[d.id]);
            const ds = driverState(d);
            const stateColor = driverStateColors[ds];
            const icon = driverStateIcons[ds];
            const col = DRIVER_COLORS[d.id];
            const active = ds === "ringing";
            const order = dispatchOrder[d.id];
            return (
              <g key={d.id}>
                <circle cx={pos.x} cy={pos.y} r={24} fill="none" stroke={col} strokeWidth={1} opacity={0.25}/>
                {active && <circle cx={pos.x} cy={pos.y} r={28} fill={stateColor} opacity={0} style={{ animation: "dPulse 0.9s ease-in-out infinite alternate" }}/>}
                <circle cx={pos.x} cy={pos.y} r={20}
                  fill={ds === "idle" ? "#191c2e" : stateColor+"28"}
                  stroke={stateColor} strokeWidth={active ? 2.5 : 1.5}
                  filter={active ? "url(#glow)" : undefined}/>
                <text x={pos.x} y={pos.y+1} textAnchor="middle" dominantBaseline="middle" fontSize={14}>{icon}</text>
                <circle cx={pos.x+14} cy={pos.y-14} r={9} fill={col} opacity={0.95}/>
                <text x={pos.x+14} y={pos.y-14} textAnchor="middle" dominantBaseline="middle" fontSize={9} fontWeight="800" fill="#000">{order}</text>
                <text x={pos.x} y={pos.y+30} textAnchor="middle" fontSize={9} fill={col} fontWeight="700">{d.label}</text>
              </g>
            );
          })}

          <g>
            <circle cx={CX} cy={CY} r={22}
              fill={isSuccess ? "#27AE6033" : "#0d1f3c"}
              stroke={isSuccess ? "#27AE60" : "#4A90D9"}
              strokeWidth={2.5} filter="url(#glow)"/>
            <text x={CX} y={CY+1} textAnchor="middle" dominantBaseline="middle" fontSize={18}>{isSuccess ? "üéâ" : "üßç"}</text>
            <text x={CX} y={CY-30} textAnchor="middle" fontSize={10} fill="#4A90D9" fontWeight="700">point A</text>
          </g>

          <style>{`
            @keyframes ripple { 0% { r:20; opacity:.7; } 100% { r:260; opacity:0; } }
            @keyframes dPulse { from { r:22; opacity:.22; } to { r:32; opacity:.04; } }
          `}</style>
        </svg>
      </div>

      <div style={{ width: "100%", maxWidth: W, background: "#1a1d2e", border: `2px solid ${isSuccess ? "#27AE60" : "#4A90D9"}`, borderRadius: 12, padding: "14px 18px", marginTop: 8, transition: "border-color 0.4s" }}>
        <div style={{ fontSize: 11, textTransform: "uppercase", letterSpacing: 1, color: "#777", marginBottom: 4 }}>Step {stage+1} / {totalSteps+1}</div>
        <div style={{ fontWeight: 700, fontSize: 15, marginBottom: 4 }}>{stageInfo.label}</div>
        <div style={{ fontSize: 13, color: "#aaa", lineHeight: 1.5 }}>{stageInfo.desc}</div>
      </div>

      <div style={{ display: "flex", gap: 10, flexWrap: "wrap", marginTop: 10, maxWidth: W, width: "100%", justifyContent: "center" }}>
        {[["#F5A623","üì≥ Signal"],["#E74C3C","‚úó No response"],["#27AE60","‚úÖ Confirmed"],["#fff","‚ë† badge = dispatch order"]].map(([c,l]) => (
          <div key={l} style={{ display: "flex", alignItems: "center", gap: 5, fontSize: 11, color: "#aaa" }}>
            <div style={{ width: 8, height: 8, borderRadius: "50%", background: c, opacity: 0.8 }}/>{l}
          </div>
        ))}
      </div>

      <div style={{ display: "flex", gap: 10, marginTop: 12 }}>
        <button onClick={() => { setStage(0); setAutoPlay(false); }} style={btnStyle("#555")}>‚Ü∫</button>
        <button onClick={() => setStage(s => Math.max(s-1,0))} disabled={stage===0} style={btnStyle("#7B68EE", stage===0)}>‚Üê Back</button>
        <button onClick={() => setAutoPlay(a => !a)} style={btnStyle(autoPlay ? "#E74C3C" : "#50C878")}>{autoPlay ? "‚è∏ Stop" : "‚ñ∂ Auto"}</button>
        <button onClick={() => setStage(s => Math.min(s+1, totalSteps))} disabled={stage===totalSteps} style={btnStyle("#7B68EE", stage===totalSteps)}>Next ‚Üí</button>
      </div>

      <div style={{ display: "flex", gap: 6, marginTop: 12, marginBottom: 20 }}>
        {Array.from({length: totalSteps+1}, (_,i) => (
          <div key={i} onClick={() => setStage(i)} style={{ width: i===stage?22:8, height: 8, borderRadius: 4, background: i<=stage ? "#4A90D9" : "#2a2d3e", cursor: "pointer", transition: "all 0.3s" }}/>
        ))}
      </div>
    </div>
  );
}

ReactDOM.createRoot(document.getElementById('root')).render(<App/>);
</script>
</body>
</html>
